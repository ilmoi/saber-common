{"version":3,"file":"solana.js","sourceRoot":"","sources":["../../../src/adapters/solana.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  Broadcaster,\n  SignAndBroadcastOptions,\n} from \"@saberhq/solana-contrib\";\nimport {\n  doSignAndBroadcastTransaction,\n  PendingTransaction,\n} from \"@saberhq/solana-contrib\";\nimport type {\n  EventEmitter,\n  SignerWalletAdapter,\n  WalletAdapterEvents,\n} from \"@solana/wallet-adapter-base\";\nimport { BaseSignerWalletAdapter } from \"@solana/wallet-adapter-base\";\nimport { GlowWalletName } from \"@solana/wallet-adapter-glow\";\nimport { PhantomWalletName } from \"@solana/wallet-adapter-phantom\";\nimport type { Connection, PublicKey, Transaction } from \"@solana/web3.js\";\n\nimport type { ConnectedWallet, WalletAdapter } from \"./types\";\n\nexport class SolanaWalletAdapter implements WalletAdapter {\n  constructor(\n    readonly adapter: Omit<\n      SignerWalletAdapter,\n      | \"sendTransaction\"\n      | keyof EventEmitter\n      | \"signTransaction\"\n      | \"signAllTransactions\"\n    > &\n      EventEmitter<WalletAdapterEvents> & {\n        signTransaction: (transaction: Transaction) => Promise<Transaction>;\n        signAllTransactions: (\n          transactions: Transaction[]\n        ) => Promise<Transaction[]>;\n      }\n  ) {}\n\n  async signAndBroadcastTransaction(\n    transaction: Transaction,\n    connection: Connection,\n    broadcaster: Broadcaster,\n    opts?: SignAndBroadcastOptions\n  ): Promise<PendingTransaction> {\n    if (!transaction.feePayer) {\n      transaction.feePayer = this.publicKey ?? undefined;\n    }\n\n    if (this.adapter.name === PhantomWalletName) {\n      if (\n        window.solana?.isPhantom &&\n        // check to see if phantom version supports this\n        \"signAndSendTransaction\" in window.solana &&\n        // Phantom doesn't handle partial signers, so if they are provided, don't use `signAndSendTransaction`\n        (!opts?.signers || opts.signers.length === 0)\n      ) {\n        // HACK: Phantom's `signAndSendTransaction` should always set these, but doesn't yet\n        if (!transaction.recentBlockhash) {\n          const latestBlockhash = await broadcaster.getLatestBlockhash();\n          transaction.recentBlockhash = latestBlockhash.blockhash;\n          transaction.lastValidBlockHeight =\n            latestBlockhash.lastValidBlockHeight;\n        }\n        const { signature } = await window.solana.signAndSendTransaction(\n          transaction,\n          opts\n        );\n        return new PendingTransaction(connection, signature);\n      }\n    } else if (this.adapter.name === GlowWalletName) {\n      if (window.glowSolana && window.glowSolana.signAndSendTransaction) {\n        // HACK: Glow's `signAndSendTransaction` should always set these, but doesn't yet\n        if (!transaction.recentBlockhash) {\n          const latestBlockhash = await broadcaster.getLatestBlockhash();\n          transaction.recentBlockhash = latestBlockhash.blockhash;\n          transaction.lastValidBlockHeight =\n            latestBlockhash.lastValidBlockHeight;\n        }\n        const result = await window.glowSolana.signAndSendTransaction({\n          serialize() {\n            return {\n              toString(): string {\n                return transaction\n                  .serialize({\n                    verifySignatures: false,\n                  })\n                  .toString(\"base64\");\n              },\n            };\n          },\n        });\n\n        return new PendingTransaction(connection, result.signature);\n      }\n    } else if (this.adapter instanceof BaseSignerWalletAdapter) {\n      // attempt to use the wallet's native transaction sending feature\n      const signature = await this.adapter.sendTransaction(\n        transaction,\n        connection,\n        opts\n      );\n      return new PendingTransaction(connection, signature);\n    }\n    return await doSignAndBroadcastTransaction(\n      this as ConnectedWallet,\n      transaction,\n      broadcaster,\n      opts\n    );\n  }\n\n  get connected(): boolean {\n    return this.adapter.connected;\n  }\n\n  get autoApprove(): boolean {\n    return false;\n  }\n\n  async signAllTransactions(\n    transactions: Transaction[]\n  ): Promise<Transaction[]> {\n    return this.adapter.signAllTransactions(transactions);\n  }\n\n  get publicKey(): PublicKey | null {\n    return this.adapter.publicKey;\n  }\n\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    if (!this.adapter) {\n      return transaction;\n    }\n\n    return this.adapter.signTransaction(transaction);\n  }\n\n  connect = async (): Promise<void> => {\n    await this.adapter.connect();\n  };\n\n  async disconnect(): Promise<void> {\n    await this.adapter.disconnect();\n  }\n\n  on(event: \"connect\" | \"disconnect\", fn: () => void): void {\n    this.adapter.on(event, fn);\n  }\n}\n"]}